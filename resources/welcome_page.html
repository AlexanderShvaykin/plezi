<html>
	<head>
		<title>appname - Feed me!!!</title>
		<style type="text/css">
			body, html
			{
				background-color: #eee;
				padding: 0; margin: 0;
				width: 100%;
				font-size: 1.05em;
			}
			h1
			{
				background-color: #ddd;
				color: #00a;
				text-align: center;
				border-bottom: 1px solid #000;
				margin: 0 0 1em 0;
				padding: 0.5em 0;
				width: 100%;
			}
			p
			{
				font-size: 1.2em;
				padding: 0 1em;			
			}
			a
			{
				color: #a04;
				text-decoration: none;
			}
			a:hover
			{
				color: #70f;
				text-decoration: underline;
			}
			#wrapper
			{
				background-color: #fff;
				margin: 1em 5%;
				padding: 0 0 2%;
				border-radius: 20px;
				min-height: 50%;
				color: #007;
			}
			#wrapper h2
			{
				background-color: #ddd;
				color: #008;
				text-align: center;
				margin: 0 0 1em 0;
				padding: 0.5em 0;
				width: 100%;
				border-radius: 20px;
			}
			#wrapper p{ padding: 0 2%;}
			pre
			{
				padding: 0.5em 0;
				background-color: #444;
				color: #ddd;
			}
		</style>
	</head>
	<body>
		<h1><a href='https://github.com/boazsegev/anorexic'>Anorexic</a> is hungry... feed it your code!</h1>
		<div id='wrapper'>
<h2>I installed Anorexic, what now?</h2>
<p>
The main code for the app is in the app file (appname.rb). here's the universal example you can rub from your favorit Ruby terminal:
</p>
<pre><code>    require 'anorexic'
    listen 3000
    route('/') { |request, response| response.body &lt;&lt; "Hello World!" }
</code></pre>
<p>
It also works with multiple services (ports), which is great for having some routes work only on SSL (*disclaimer, not all Rack servers serve SSL. WEBrick does, but it's slower):
<pre><code>    require 'anorexic'

    listen 3000 # => server: 'thin', 'puma', 'webrick' - searched for in order.
    route('/') { |request, response| response.body &lt;&lt; "Hello World from 3000!" }

    listen 8080, ssl_self: true , server: 'webrick'
    route('/') { |request, response| response.body &lt;&lt; "SSL Hello World from 8080!" }

    shared_route('/people') { |request, response| response.body &lt;&lt; "Hello People!" }
</code></pre>
</p>


<h2>Routes?</h2>
<p>
Routes have paths that tell the application which code to run for every request it recieves. The route's path is the part in bold: http://www.server.com<b>/the/stuff/they/request</b>?paramaters=params[:paramaters]
</p>
<p>
As long as Anorexic uses the Anorexic::RackServer class (we could change that, but why would we?), the routes will work the same for all the listening ports.
</p>
<p>
	 <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> allows your code to choose it's routes dynamically, in the order they are created. like so:
</p>
<pre><code>    require 'anorexic'
    listen
    # this route declines to answer
    route('/') { |req, res| res.body &lt;&lt; "I Give Up!"; false }
    # this route wins
    route('/') { |req, res| res.body &lt;&lt; "I Win!" }
    # this route never sees the light of day
    route('/') { |request, response| response.body &lt;&lt; "Help Me!" }
</code></pre>
<p>
	 <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> accepts Regexp routes and defines a short cut for a catch-all route:
</p>
<pre><code>    require 'anorexic'
    listen

    # this route accepts paths that start with a number (i.e.: /nonumber)
    route(/^\/[\d]+[\D]+/) { |req, res| res.body &lt;&lt; "Give me more numbers :)" }

    # this route accepts paths that are just numbers (i.e.: /87652)
    route(/^\/[\d]+$/) { |req, res| res.body &lt;&lt; "I Love Numbers!" }

    # this route accepts paths that don't have any number (i.e.: /nonumber)
    route(/^\/[\D]+$/) { |req, res| res.body &lt;&lt; "Where're my numbers :(" }

    # this route catches everything else.
    route('*') { |request, response| response.body &lt;&lt; "Gotcha!" }
</code></pre>



<h2>Controllers</h2>
<p>
Controllers are `special` classes.
</p>
<p>
In fact, Controllers are so special, they are the reason the Anorexic project started - to build light efficient controllers that can replace the heavy core experienced while using Rails or Sinatra based frameworks.
</p>
<p>
Although Controllers can be any class, they have a lot of advantages over defining routes using blocks of code. look at this:
</p>
<pre><code>    require 'anorexic'
    listen
    route "/", Anorexic::StubController
</code></pre>
<p>
Building our own controller is as easy as defining a class:
</p>
<pre><code>    class MyController
        def index
            "Hello World!"
        end
        def demo
            "This is a demo path!"
        end
        def no
            false
        end

        # show, update, save, defete, before and after are extra special.
        def show
            "Looking for the #{params[:id]} object?"
        end
    end

	require 'anorexic'
    listen
    route "/", MyController
</code></pre>
<p>
Read more about controllers <a href='http://rubydoc.info/gems/anorexic/frames'>on our documentation page</a>
.</p>

<h2>More</h2>
<p>
<a href='https://github.com/boazsegev/anorexic'>Anorexic</a> is thin, light and built for lego-block world of open-source. If you want to learn more, <a href='http://rubydoc.info/gems/anorexic/frames'>read the documentation</a>. We actually tried to write some for you to enjoy...
</p>
		</div>
	</body>
</html>
