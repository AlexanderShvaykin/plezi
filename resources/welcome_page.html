<html>
	<head>
		<title>appname - Feed me!!!</title>
		<style type="text/css">
			body, html
			{
				background-color: #eee;
				padding: 0; margin: 0;
				width: 100%;
				font-size: 1em;
			}
			body, html, h1, #wrapper, #wrapper h2
			{
				background-image: url(/images/anorexic_gray.png);
				background-position: center top;
				background-origin: inherit;
				background-repeat: no-repeat;
				background-size: 88% auto;
				background-attachment: fixed;

			}

			h1
			{
				background-color: #ddd;
				color: #00a;
				text-align: center;
				border-bottom: 1px solid #000;
				margin: 0 0 1em 0;
				padding: 0.5em 0;
				width: 100%;
			}
			p
			{
				font-size: 1.2em;
				padding: 0 1em;			
			}
			a
			{
				color: #a04;
				text-decoration: none;
			}
			a:hover
			{
				color: #70f;
				text-decoration: underline;
			}
			#wrapper
			{
				background-color: #fff;
				margin: 1em 5%;
				padding: 0 0 2%;
				border-radius: 20px;
				min-height: 50%;
				color: #007;
			}
			#wrapper h2
			{
				background-color: #ddd;
				color: #008;
				text-align: left;
				margin: 0 0 1em 0;
				padding: 0.5em 5%;
				border-radius: 20px;
			}
			#wrapper p{ padding: 0 2%;}
			pre
			{
				border-radius: 20px;
				padding: 0.5em 0;
				background-color: #444;
				color: #ddd;
			}
		</style>
	</head>
	<body>
		<h1><a href='https://github.com/boazsegev/anorexic'>Anorexic</a> is hungry... feed it your code!</h1>
		<div id='wrapper'>
<h2>I installed <a href='https://github.com/boazsegev/anorexic'>Anorexic</a>, what now?</h2>
<p>
Welcome to the amazing world of <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> - an agnostic Ruby framework that's hungry to eat up your code.
</p>
<p>
The <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> framework can even serve multiple services (ports), which is great for having some routes work only on SSL <span style='font-size:0.9em'>(*disclaimer, not all Rack servers SSL setting are supported. Thin and WEBrick are)</span>:
</p>
<pre><code>    require 'anorexic'

    listen 3000 
    route('/') { |request, response| response.body &lt;&lt; "Hello World from 3000!" }

    listen 8080, ssl_self: true
    route('/') { |request, response| response.body &lt;&lt; "SSL Hello World from 8080!" }

    shared_route('/people') { |request, response| response.body &lt;&lt; "Hello People!" }
</code></pre>
<p>
<a href='https://github.com/boazsegev/anorexic'>Anorexic</a> is thin, light and built for lego-block world of open-source. If you want to learn more, <a href='http://rubydoc.info/gems/anorexic/frames'>read the documentation</a>. We actually tried to write some for you to enjoy...
</p>

</p>

<h2>Building with Gems</h2>
<p>
	The <b>first</b> think you should do, is open your Gemfile and decide which gems you want to put in.
</p>
<p>
	You already know what app you want to make - what does it need? does it need a database? maybe simplify html markup using haml?
</p>
<p>
	<a href='https://github.com/boazsegev/anorexic'>Anorexic</a> takes the lego blocks approach - this framework is a wonderful clean slate. Now is the time to add the stuff you want.
</p>
<h2>Routes?</h2>
<p>
Routes have paths that tell the application which code to run for every request it recieves. The route's path is the part in bold: http://www.server.com<b>/the/stuff/they/request</b>?paramaters=params[:paramaters]
</p>
<p>
Since <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> uses the Anorexic::RackServer class (we could change that, but why would we?), the routes will work the same for all the listening ports.
</p>
<p>
	 <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> routes allows your code to choose it's routes dynamically, in the order they are created. like so:
</p>
<pre><code>    require 'anorexic'
    listen
    # this route declines to answer
    route('/') { |req, res| res.body &lt;&lt; "I Give Up!"; false }
    # this route wins
    route('/') { |req, res| res.body &lt;&lt; "I Win!" }
    # this route never sees the light of day
    route('/') { |request, response| response.body &lt;&lt; "Help Me!" }
</code></pre>
<p>
	 <a href='https://github.com/boazsegev/anorexic'>Anorexic</a> accepts Regexp routes and defines a short cut for a catch-all route:
</p>
<pre><code>    require 'anorexic'
    listen

    # this route accepts paths that start with a number (i.e.: /nonumber)
    route(/^\/[\d]+[\D]+/) { |req, res| res.body &lt;&lt; "Give me more numbers :)" }

    # this route accepts paths that are just numbers (i.e.: /87652)
    route(/^\/[\d]+$/) { |req, res| res.body &lt;&lt; "I Love Numbers!" }

    # this route accepts paths that don't have any number (i.e.: /nonumber)
    route(/^\/[\D]+$/) { |req, res| res.body &lt;&lt; "Where're my numbers :(" }

    # this route catches everything else.
    route('*') { |request, response| response.body &lt;&lt; "Gotcha!" }
</code></pre>

<h2>Controllers</h2>
<p>
Controllers are `special` classes.
</p>
<p>
In fact, Controllers are so special, they are the reason the Anorexic project started - to build light efficient controllers that can replace the heavy core experienced while using Rails or Sinatra based frameworks.
</p>
<p>
Although Controllers can be any class, they have a lot of advantages over defining routes using blocks of code. look at this:
</p>
<pre><code>    require 'anorexic'
    listen
    route "/", Anorexic::StubController
</code></pre>
<p>
Building our own controller is as easy as defining a class:
</p>
<pre><code>    class MyController
        def index
            "Hello World!"
        end
        def demo
            "This is a demo path!"
        end
        def no
            false
        end

        # show, update, save, defete, before and after are extra special.
        def show
            "Looking for the #{params[:id]} object?"
        end
    end

	require 'anorexic'
    listen
    route "/", MyController
</code></pre>
<p>
Read more about controllers <a href='http://rubydoc.info/gems/anorexic/frames'>on our documentation page</a>
.</p>
		</div>
	</body>
</html>
